@_exported import protocol NIO.EventLoop
@_exported import class NIO.EventLoopFuture

public final class Container {
    /// Service `Environment` (e.g., production, dev). Use this to dynamically swap services based on environment.
    public let env: Environment
    
    /// Available services. This struct contains all of this `Container`'s available service implementations.
    public let services: Services
    
    /// All `Provider`s that have been registered to this `Container`'s `Services`.
    public var providers: [Provider] {
        return self.services.providers
    }
    
    /// This container's event loop.
    public let eventLoop: EventLoop
    
    /// Stores cached singleton services.
    private var cache: ServiceCache
    
    private var didShutdown: Bool
    
    public init(env: Environment = .development, services: Services, on eventLoop: EventLoop) {
        self.env = env
        self.services = services
        self.eventLoop = eventLoop
        self.cache = .init()
        self.didShutdown = false
    }
    
    /// Creates a service for the supplied interface or type.
    ///
    ///     let redis = try container.make(RedisCache.self)
    ///
    /// If a protocol is supplied, a service conforming to the protocol will be returned.
    ///
    ///     let client = try container.make(Client.self)
    ///     print(type(of: client)) // EngineClient
    ///
    /// Subsequent calls to `make(_:)` for the same type will yield a cached result.
    ///
    /// - parameters:
    ///     - type: Service or interface type `T` to create.
    /// - throws: Any error finding or initializing the requested service.
    /// - returns: Initialized instance of `T`
    public func make<S>(_ service: S.Type = S.self) throws -> S {
        assert(!self.didShutdown, "Container.shutdown() has been called, this Container is no longer valid.")
        
        // check if cached
        if let cached = self.cache.get(service: S.self) {
            return cached
        }
        
        // create service lookup identifier
        let id = ServiceID(S.self)
        
        // fetch service factory if one exists
        guard let factory = self.services.factories[id] as? ServiceFactory<S> else {
            fatalError("No services available for \(S.self)")
        }
        
        // create the service
        var instance = try factory.serviceMake(for: self)
        
        // check for any extensions
        if let extensions = self.services.extensions[id] as? [ServiceExtension<S>], !extensions.isEmpty {
            // loop over extensions, modifying instace
            try extensions.forEach { try $0.serviceExtend(&instance, self) }
        }
        
        // cache if singleton
        if factory.isSingleton {
            self.cache.set(service: instance)
        }
        
        // return created and extended instance
        return instance
    }
    
    public func willBoot() -> EventLoopFuture<Void> {
        return .andAllSucceed(self.providers.map { $0.willBoot(self) }, on: self.eventLoop)
    }
    
    public func didBoot() -> EventLoopFuture<Void> {
        return .andAllSucceed(self.providers.map { $0.didBoot(self) }, on: self.eventLoop)
    }
    
    public func shutdown() -> EventLoopFuture<Void> {
        return EventLoopFuture<Void>.andAllSucceed(
            self.providers.map { $0.willShutdown(self) },
            on: self.eventLoop
        ).map {
            self.cache.clear()
            self.didShutdown = true
        }
    }
    
    deinit {
        assert(self.didShutdown, "Container.shutdown() was not called before Container deinitialized")
    }
}
